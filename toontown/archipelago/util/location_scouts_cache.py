# A common class to be used by both AI and clients have some sort of storage will map
# Location IDs to the string representation of the reward that the location contains.
#
# For example, if our TTC ToonTask #3 contains Joe's Diamond Sword (idk some random item lol) we need
# to be able to have some sort of storage for this information (received via LocationInfo packets handled by the ai)
# and be able to send it to the clients through astron so they can display it however they need to
from typing import Dict, List, Tuple


class LocationScoutsCache:

    def __init__(self):

        # This class is no more than a wrapper for a dictionary that maps our numeric AP Location IDs to Strings that
        # represent an english form of the reward it is storing
        self._data_cache: Dict[int, str] = {}

    def put(self, key, value):
        self._data_cache[key] = value

    def get(self, key, default=None):
        return self._data_cache.get(key, default)

    def keys(self):
        return self._data_cache.keys()

    def values(self):
        return self._data_cache.values()

    def items(self):
        return self._data_cache.items()

    # Given another LocationScoutsCache, take all key value pairs present and add them to this one
    # If update is True, duplicate keys will be overridden, False means we keep our old keys and values
    def merge(self, other: "LocationScoutsCache", update=True):
        for key, value in other.items():

            # If no updates and key is already present skip
            if not update and key in self._data_cache:
                continue

            self.put(key, value)

    # Now we need to define methods to make this data structure astron safe
    # Call this method to get an "astron safe" version of this data structure
    # (A list that contains key-value pairs as tuples)
    def struct(self) -> List[Tuple[int, str]]:
        ret = []
        for key, value in self._data_cache.items():
            ret.append((key, value))
        return ret

    # Now a class method that will allow us to instatiate this instance with input generated by the output of struct()
    @classmethod
    def from_struct(cls, data: List[Tuple[int, str]]):

        cache = cls()
        for kvp in data:
            key, value = kvp
            cache.put(key, value)

        return cache

